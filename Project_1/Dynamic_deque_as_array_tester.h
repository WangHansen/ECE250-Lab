
/**************************************************
 * Deque_asArray_tester
 * A class for testing dynamic deques-as-arrays.
 *
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006-8 by Douglas Wilhelm Harder.  All rights reserved.
 * Updated: Sept 17th, 2014 - Tiuley Alguindigue
 * Change deque from template class to class
 * Change cout to print()  
 * DO NOT EDIT THIS FILE
 **************************************************/

#ifndef DEQUE_AS_ARRAY_TESTER_H
#define DEQUE_AS_ARRAY_TESTER_H
#define PARAMETERIZED

#include "Exception.h"
#include "Tester.h"
#include "Dynamic_deque_as_array.h"

#include <iostream>


class Dynamic_deque_as_array_tester:public Tester<Dynamic_deque_as_array > {
	using Tester< Dynamic_deque_as_array >::object;
	using Tester< Dynamic_deque_as_array >::command;

	public:
		Dynamic_deque_as_array_tester( Dynamic_deque_as_array *obj = 0 ):Tester< Dynamic_deque_as_array >( obj ) {
			// empty
		}

		void process();
};

/****************************************************
 * void process()
 *
 * Process the current command.  For dynamic-deques-as-arrays, these include:
 *
 *  Constructors
 *
 *   new             constructor     create a deque with the default array size
 *   new: n          constructor     create a deque with an array size of n
 *
 *  Accessors
 *
 *   size n          size            the size equals n
 *   capacity n      capacity        the capcity equals n
 *   empty b         empty           the result is the boolean value b
 *   head n          head            n is the first element in the deque
 *   head!           head            the underflow exception is thrown
 *   tail n          tail            n is the last element in the deque
 *   tail!           tail            the underflow exception is thrown
 *
 *  Mutators
 *
 *   enqueue_head n  enqueue_head    the element can be enqueued (always succeeds)
 *   dequeue_head n  dequeue_head    the head can be dequeued
 *   dequeue_head!   dequeue_head    the underflow exception is thrown
 *   enqueue_head!   enqueue_head    the overflow exception is thrown
 *   enqueue_tail n  enqueue_tail    the element can be enqueued (always succeeds)
 *   dequeue_tail n  dequeue_tail    the tail can be dequeued
 *   dequeue_tail!   dequeue_tail    the underflow exception is thrown
 *   enqueue_tail!   enqueue_tail    the overflow exception is thrown
 *   clear                           remove all elements in the deque 
 *
 *  Others
 *
 *   print                           print the deque (for testing only)
 *   summary                         prints the amount of memory allocated
 *                                   minus the memory deallocated
 *   details                         prints a detailed description of which
 *                                   memory was allocated with details
 *
 ****************************************************/


void Dynamic_deque_as_array_tester::process() {

	// std::cout<<"\n  size: "<<object->size()<<std::endl;
	// std::cout<<"  capacity: "<<object->capacity()<<std::endl;
	// std::cout<<"  head index: "<<object->array_head<<std::endl;
	// std::cout<<"  tail index: "<<object->array_tail<<std::endl;
	// std::cout<<"  Array: "; 
	// for(int l=0; l<object->array_size; l++){
	// 	std::cout<<object->array[l]<<" ";
	// }
	// std::cout<<" "<<std::endl;

	if ( command == "size" ) {
		// check if the size equals the next integer read

		int expected_size;

		std::cin >> expected_size;

		int actual_size = object->size();

		if ( actual_size == expected_size ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in size(): expecting the value '" << expected_size << "' but got '" << actual_size << "'" << std::endl;
		}
	} else if ( command == "capacity" ) {
		// check if the capacity equals the next integer read

		int expected_capacity;

		std::cin >> expected_capacity;

		int actual_capacity = object->capacity();

		if ( actual_capacity == expected_capacity ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in capacity(): expecting the value '" << expected_capacity << "' but got '" << actual_capacity << "'" << std::endl;
		}
	} else if ( command == "empty" ) {
		// check if the empty status equals the next boolean read

		bool expected_empty;

		std::cin >> expected_empty;

		bool actual_empty = object->empty();

		if ( actual_empty == expected_empty ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in empty(): expecting the value '" << expected_empty << "' but got '" << actual_empty << "'" << std::endl;
		}
	} else if ( command == "head" ) {
		// checks if the first integer in the deque equals the next integer read

		int expected_head;

		std::cin >> expected_head;

		int actual_head = object->head();

		if ( actual_head == expected_head ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in head(): expecting the value '" << expected_head << "' but got '" << actual_head << "'" << std::endl;
		}
	} else if ( command == "head!" ) {
		// head of an empty deque - catch an exception

		int actual_head;

		try {
			actual_head = object->head();
			std::cout << "Failure in head(): expecting to catch an exception but got '" << actual_head << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in head(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "tail" ) {
		// checks if the last integer in the deque equals the next integer read

		int expected_tail;

		std::cin >> expected_tail;

		int actual_tail = object->tail();

		if ( actual_tail == expected_tail ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in tail(): expecting the value '" << expected_tail << "' but got '" << actual_tail << "'" << std::endl;
		}
	} else if ( command == "tail!" ) {
		// head of an empty deque - catch an exception

		int actual_tail;

		try {
			actual_tail = object->tail();
			std::cout << "Failure in tail(): expecting to catch an exception but got '" << actual_tail << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in tail(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "enqueue_head" ) {
		// enqueue the next integer read to the front of the deque

		int obj;

		std::cin >> obj;

		object->enqueue_head( obj );
		std::cout << "Okay" << std::endl;
		
		
		
		} else if ( command == "enqueue_head!" ) {
		

	    int obj;

		try {
			object->enqueue_head( obj );
			std::cout << "Failure in enqueue_head(): expecting to catch an exception but got '" << obj << "'" << std::endl;
		} catch( overflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in enqueue_head(): expecting an overflow exception but caught a different exception" << std::endl;
		}
		
		
		
		
		
	} else if ( command == "dequeue_head" ) {
		// dequeue the first integer from the deque

		int expected_dequeued_element;

		std::cin >> expected_dequeued_element;

		int actual_dequeued_element = object->dequeue_head();

		if ( actual_dequeued_element == expected_dequeued_element ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in dequeue_head(): expecting the value '" << expected_dequeued_element << "' but got '" << actual_dequeued_element << "'" << std::endl;
		}
	} else if ( command == "dequeue_head!" ) {
		// dequeue from an empty deque - catch an exception

		int actual_dequeued_element;

		try {
			actual_dequeued_element = object->dequeue_head();
			std::cout << "Failure in dequeue_head(): expecting to catch an exception but got '" << actual_dequeued_element << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in dequeue_head(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "enqueue_tail" ) {
		// enqueue the next integer read to the back of the deque

		int obj;

		std::cin >> obj;

		object->enqueue_tail( obj );
		std::cout << "Okay" << std::endl;
		
		
		} else if ( command == "enqueue_tail!" ) {
		

	    int obj;

		try {
			object->enqueue_tail( obj );
			std::cout << "Failure in enqueue_tail(): expecting to catch an exception but got '" << obj << "'" << std::endl;
		} catch( overflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in enqueue_tail(): expecting an overflow exception but caught a different exception" << std::endl;
		}
		
		
		
		
		
		
	} else if ( command == "dequeue_tail" ) {
		// dequeue the last integer from the deque

		int expected_dequeued_element;

		std::cin >> expected_dequeued_element;

		int actual_dequeued_element = object->dequeue_tail();

		if ( actual_dequeued_element == expected_dequeued_element ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in dequeue_tail(): expecting the value '" << expected_dequeued_element << "' but got '" << actual_dequeued_element << "'" << std::endl;
		}
	} else if ( command == "dequeue_tail!" ) {
		// dequeue from an empty deque - catch an exception

		int actual_dequeued_element;

		try {
			actual_dequeued_element = object->dequeue_tail();
			std::cout << "Failure in dequeue_tail(): expecting to catch an exception but got '" << actual_dequeued_element << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in dequeue_tail(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "clear" ) {
		object->clear();

		std::cout << "Okay" << std::endl;
	    
/*  	} else if ( command == "print" ) {
		object->print();

		std::cout << "Okay" << std::endl;
*/	   
	   
	   
	//} else if ( command == "cout" ) {
	//	std::cout << *object << std::endl;

	} else {
		std::cout << command << ": Command not found." << std::endl;
	}
}
#endif
